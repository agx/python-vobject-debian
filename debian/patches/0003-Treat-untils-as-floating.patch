From: Morgen Sagen <sagen@apple.com>
Date: Mon, 4 Jan 2010 20:27:01 +0100
Subject: [PATCH] Treat untils as floating

---
 vobject/icalendar.py |   19 ++++++++++++++++---
 1 files changed, 16 insertions(+), 3 deletions(-)

diff --git a/vobject/icalendar.py b/vobject/icalendar.py
index 4a1da7c..8917476 100644
--- a/vobject/icalendar.py
+++ b/vobject/icalendar.py
@@ -427,6 +427,18 @@ class RecurringComponent(Component):
                         if dtstart.tzinfo is not None:
                             until = until.astimezone(dtstart.tzinfo)
 
+                        # RFC2445 actually states that UNTIL must be a UTC value. Whilst the
+                        # changes above work OK, one problem case is if DTSTART is floating but
+                        # UNTIL is properly specified as UTC (or with a TZID). In that case dateutil
+                        # will fail datetime comparisons. There is no easy solution to this as
+                        # there is no obvious timezone (at this point) to do proper floating time
+                        # offset compisons. The best we can do is treat the UNTIL value as floating.
+                        # This could mean incorrect determination of the last instance. The better
+                        # solution here is to encourage clients to use COUNT rather than UNTIL
+                        # when DTSTART is floating.
+                        if dtstart.tzinfo is None:
+                            until = until.replace(tzinfo=None)
+
                         rule._until = until
                     
                     # add the rrule or exrule to the rruleset
@@ -473,7 +485,7 @@ class RecurringComponent(Component):
             untilSerialize = lambda x: dateTimeToString(x, True)
 
         for name in DATESANDRULES:
-            if hasattr(self.contents, name):
+            if name in self.contents:
                 del self.contents[name]
             setlist = getattr(rruleset, '_' + name)
             if name in DATENAMES:
@@ -1663,9 +1675,10 @@ def stringToTextValues(s, listSeparator=',', charList=None, strict=False):
                 else:
                     current.append(char)
             else:
-                state = "read normal"
+                #state = "read normal"
                 # leave unrecognized escaped characters for later passes
-                current.append('\\' + char)
+                #current.append('\\' + char)
+                raise ParseError("error: illegal escape sequence: '\\%s'" % (char,))
 
         elif state == "end":    #an end state
             if len(current) or len(results) == 0:
-- 
